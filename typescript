// ...
// Helper
async function generateInvoiceNumber(ctx: any, businessId: any, type: string, dateTimestamp: number) {
    // ... implementation
}

export const create = mutation({
  args: {
    businessId: v.id("businesses"),
    customerId: v.id("customers"),
    invoiceNumber: v.string(),
    // ...
    invoicePrefix: v.optional(v.string()),
    quotePrefix: v.optional(v.string()),
    creditNotePrefix: v.optional(v.string()),
    // ... keep existing code
  },
  handler: async (ctx, args) => {
    const userId = ctx.userId;
    const business = await ctx.db.get(args.businessId);
    if (!business || business.userId !== userId) throw new Error("Unauthorized");

    let invoiceNumber = args.invoiceNumber;
    if (!invoiceNumber || invoiceNumber === "AUTO") {
        invoiceNumber = await generateInvoiceNumber(ctx, args.businessId, args.type, args.issueDate);
    }

    // Auto-Entrepreneur Logic Enforcement: NO VAT
    // ... keep existing code

    const invoiceData = {
      businessId: args.businessId,
      customerId: args.customerId,
      invoiceNumber: invoiceNumber!,
      // ...
    }
    // ...
  }
})

export const update = mutation({
  args: {
    // ... keep existing code
    invoicePrefix: v.optional(v.string()),
    quotePrefix: v.optional(v.string()),
    creditNotePrefix: v.optional(v.string()),
    // ... keep existing code
  },
  // ... keep existing code
});

// ...
    businesses: defineTable({
      // ...
      // Invoice Sequencing Preferences
      invoicePrefix: v.optional(v.string()),
      quotePrefix: v.optional(v.string()),
      creditNotePrefix: v.optional(v.string()),
      // ...
    })
    // ...
    invoiceCounters: defineTable({
      businessId: v.id("businesses"),
      type: v.union(
        v.literal("invoice"),
        v.literal("quote"),
        v.literal("credit_note")
      ),
      year: v.number(),
      count: v.number(),
    }).index("by_business_type_year", ["businessId", "type", "year"]),
    // ...
}